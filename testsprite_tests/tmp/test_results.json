[
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "e9465adc-bdb8-4585-bf6d-bd58dfbefb77",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC001-Public Portfolio Homepage Load and Render",
    "description": "Verify that the public homepage loads successfully and renders all main sections: hero video auto-playing, project gallery with media cards, client logos carousel, and footer contact info.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Exclusive Project Launch Event').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The public homepage did not load successfully or one of the main sections (hero video, project gallery, client logos carousel, footer contact info) is missing or not rendered correctly.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080090159839//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.136Z",
    "modified": "2025-11-25T14:14:50.288Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "dd47dcc7-0500-485f-98ea-c4e1db898e20",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC002-Project Media Card Interaction and Lightbox Display",
    "description": "Ensure that clicking on a project media card opens a lightbox or modal showing the high-resolution image or playing the video.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=High-Resolution Media Displayed').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Clicking on a project media card did not open a lightbox or modal displaying the media in high resolution or auto-playing the video as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080085842191//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.143Z",
    "modified": "2025-11-25T14:14:45.970Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "95abfa2b-294f-463a-9ca1-098ebcfaa669",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC003-Admin Login and Access to Filament Dashboard",
    "description": "Verify admin users can successfully log into the FilamentPHP admin dashboard and access project and client management resources.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access to confidential financial reports').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Admin users could not successfully log into the FilamentPHP admin dashboard or access project and client management resources as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080087272124//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.156Z",
    "modified": "2025-11-25T14:14:47.427Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "3bbc8ed9-1d38-4701-a0de-502b7bd51d84",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC004-Admin Project CRUD Operations",
    "description": "Test creating, editing, and deleting portfolio projects with media uploads, SEO metadata, visibility toggles, and layout selection.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Project Successfully Created and Displayed').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution for creating, editing, and deleting portfolio projects did not complete successfully. The project was not found in the project list as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080088380515//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.163Z",
    "modified": "2025-11-25T14:14:48.530Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "d6ea8347-8563-4043-a16b-bc5972994141",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC005-Admin Client Logo Management CRUD",
    "description": "Verify admin can create, edit, reorder, and delete client logos for the client carousel with website URLs and visibility toggles.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Client Logo Successfully Created').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The admin was unable to create, edit, reorder, or delete client logos as required by the test plan. The expected confirmation message 'Client Logo Successfully Created' was not found, indicating failure in client logo management functionality.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080097552564//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.171Z",
    "modified": "2025-11-25T14:14:57.699Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "382bfa84-0776-4b34-b9c8-67525c0e722b",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC006-Global Site Settings Management and Reflection",
    "description": "Test updating global site settings such as hero video, profile bio, social links, and SEO defaults via the admin singleton settings page and verify changes reflect on the public site.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Global Site Settings Updated Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to update global site settings including hero video, profile bio, social links, and SEO defaults. The expected success confirmation message 'Global Site Settings Updated Successfully' was not found on the page.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080080252351//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.178Z",
    "modified": "2025-11-25T14:14:40.459Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "8657a320-266c-457c-ad19-6d0ad8d9fa0f",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC007-Draft and Published Content Visibility Control",
    "description": "Validate that projects and client logos marked as draft are not visible on the public site, whereas published content is publicly accessible.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to admin login page to login as admin and create draft project and client logo\n        await page.goto('http://localhost:8000/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input admin email and password, then click Sign in button\n        frame = context.pages[-1]\n        # Input admin email\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('hello@laurensiusdimas.com')\n        \n\n        frame = context.pages[-1]\n        # Input admin password\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        # Click Sign in button\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Projects section to create a new draft project\n        frame = context.pages[-1]\n        # Click Projects in admin menu\n        elem = frame.locator('xpath=html/body/div/aside/nav/ul/li/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'New project' button to start creating a new draft project\n        frame = context.pages[-1]\n        # Click 'New project' button\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/header/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the project title, slug, category, section, layout, description, and set visibility to draft\n        frame = context.pages[-1]\n        # Input project title\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/form/div/div/section/div/div/div/div/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Draft Project Example')\n        \n\n        # -> Complete filling slug, category, description, set visibility to draft, and submit the form\n        frame = context.pages[-1]\n        # Input project slug\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/form/div/div/section/div/div/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('draft-project-example')\n        \n\n        frame = context.pages[-1]\n        # Input project category\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/form/div/div/section/div/div/div/div[3]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Example Category')\n        \n\n        frame = context.pages[-1]\n        # Input project description\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/form/div/div/section/div/div/div/div[6]/div/div/div[2]/div/div/div/trix-editor').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('This is a draft project description for testing visibility.')\n        \n\n        # -> Toggle visibility switch to draft (unpublished) and click Create button to save the draft project\n        frame = context.pages[-1]\n        # Toggle visibility switch to draft (unpublished)\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/form/div/div[4]/section/div/div/div/div/div/div/div/label/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Create button to save the draft project\n        elem = frame.locator('xpath=html/body/div/aside/div/header/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Draft Project Example - Visible to Public')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Draft projects and client logos should NOT be visible on the public site, but draft content was found visible.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080332789725//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.188Z",
    "modified": "2025-11-25T14:18:52.989Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "3d79fd91-4ac2-4a58-807e-d2b93def1078",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC008-Media Upload Validation and URL Resolution",
    "description": "Verify media upload functionality allows supported image and video file types within size limits, and that media URLs resolve correctly for both local filesystem storage and external URLs.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Unsupported file type error: Upload rejected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Media upload functionality did not reject unsupported file types or files exceeding size limits as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/176408008299727//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.196Z",
    "modified": "2025-11-25T14:14:43.122Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "eca460bf-edb5-404b-bb2a-75d4e10a490b",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC009-Project and Client Drag-and-Drop Reordering Persistence",
    "description": "Confirm that drag-and-drop reordering of projects and client logos in admin interface persists on save and is accurately reflected in the frontend display order.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Login to admin dashboard to start the reorder test as per instructions\n        await page.goto('http://localhost:8000/admin/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and password, then click Sign in button to login to admin dashboard.\n        frame = context.pages[-1]\n        # Input the email address for login\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('hello@laurensiusdimas.com')\n        \n\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        # Click the Sign in button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Projects' link in the sidebar to navigate to project management section.\n        frame = context.pages[-1]\n        # Click on Projects link in sidebar to go to project management section\n        elem = frame.locator('xpath=html/body/div/aside/nav/ul/li/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Reorder records' button to enable drag-and-drop reordering of projects.\n        frame = context.pages[-1]\n        # Click the 'Reorder records' button to enable drag-and-drop mode for projects\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/div/div/div/div/div/div/span/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Perform drag-and-drop reorder of projects by swapping the first and last projects, then save the changes.\n        frame = context.pages[-1]\n        # Drag handle of the last project 'Order Sekarang' to the top position (simulate drag-and-drop)\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/div/div/div/div[3]/table/tbody/tr[4]/td/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Drag handle of the first project 'Hardy Motor' to the bottom position (simulate drag-and-drop)\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/div/div/div/div[3]/table/tbody/tr/td/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click 'Finish reordering records' button to save the new project order\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/div/div/div/div/div/div/span/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Drag-and-drop reorder successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Drag-and-drop reordering of projects and client logos did not persist on save or was not accurately reflected in the frontend display order as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080272076279//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.208Z",
    "modified": "2025-11-25T14:17:52.274Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "195e521e-e91e-4f76-96a6-ef11d3339f99",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC010-Performance Benchmark for Page Load and Media Lazy Loading",
    "description": "Validate that the portfolio homepage meets defined performance benchmarks for page load times and that media elements (images/videos) implement lazy loading to optimize user experience.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Performance benchmarks met successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The portfolio homepage did not meet the defined performance benchmarks for page load times or media elements are not implementing lazy loading as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080091934724//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.224Z",
    "modified": "2025-11-25T14:14:52.132Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "b4d51372-344b-40fe-83ca-05c18f2e8cc1",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC011-Responsive UI and Accessibility Compliance",
    "description": "Verify that the application UI is responsive across common device screen sizes and meets accessibility standards such as proper alt text, keyboard navigation, and ARIA attributes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Nonexistent Accessibility Feature').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The application UI did not meet the accessibility standards or responsive design requirements as specified in the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080088586859//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.233Z",
    "modified": "2025-11-25T14:14:48.745Z"
  },
  {
    "projectId": "e39835eb-851a-40ad-bc58-f984455a3268",
    "testId": "05889c00-8c4f-4d01-b180-b711fa43aa46",
    "userId": "84289488-e0c1-700e-d856-322ae4b2e60b",
    "title": "TC012-Security: Route and Endpoint Access Control",
    "description": "Ensure all admin routes and API endpoints are secured with authentication and authorization checks, preventing unauthorized access.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Attempt to navigate to the admin dashboard or admin routes directly to test access control, bypassing the broken home page.\n        await page.goto('http://localhost:8000/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input non-admin user credentials and attempt to login to test access to admin routes.\n        frame = context.pages[-1]\n        # Input non-admin user email\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('user@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input non-admin user password\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        # Click Sign in button to login as non-admin user\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid admin user credentials (hello@laurensiusdimas.com / password) and attempt to login.\n        frame = context.pages[-1]\n        # Input admin user email\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('hello@laurensiusdimas.com')\n        \n\n        frame = context.pages[-1]\n        # Input admin user password\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        # Click Sign in button to login as admin user\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Log out admin user and attempt to access admin routes without authentication to verify redirection or access denied.\n        frame = context.pages[-1]\n        # Click Sign out button to log out admin user\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/div/div/div/div/section/div/div/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to access admin dashboard URL /admin without authentication to verify redirection or access denied.\n        await page.goto('http://localhost:8000/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to login with a non-admin user to test access denial on admin routes.\n        frame = context.pages[-1]\n        # Input non-admin user email\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('user@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input non-admin user password\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        # Click Sign in button to login as non-admin user\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test access to admin API endpoints without authentication to verify access denial or unauthorized response.\n        await page.goto('http://localhost:8000/api/admin/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Identify and test other known admin API endpoints or verify correct API endpoint URLs to test authentication and authorization enforcement.\n        await page.goto('http://localhost:8000/api/admin/users', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to admin UI routes to identify any API endpoints or links that can be tested for authentication and authorization enforcement.\n        await page.goto('http://localhost:8000/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input valid admin credentials and login to verify access to admin routes and API endpoints.\n        frame = context.pages[-1]\n        # Input admin email\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('hello@laurensiusdimas.com')\n        \n\n        frame = context.pages[-1]\n        # Input admin password\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        # Click Sign in button\n        elem = frame.locator('xpath=html/body/div/div/main/div/section/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test access to admin API endpoints with admin authentication to verify access is granted.\n        await page.goto('http://localhost:8000/api/admin/users', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Explore admin UI to find any API endpoint references or documentation links to identify correct admin API endpoints for testing authentication and authorization.\n        await page.goto('http://localhost:8000/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on 'Clients' link to explore admin UI and check for API endpoints or further access control verification.\n        frame = context.pages[-1]\n        # Click Clients link in admin dashboard\n        elem = frame.locator('xpath=html/body/div/aside/nav/ul/li/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Unauthorized Access to Admin Dashboard').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Admin routes and API endpoints are not properly secured. Unauthorized access was not denied as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84289488-e0c1-700e-d856-322ae4b2e60b/1764080405957173//tmp/test_task/result.webm",
    "created": "2025-11-25T14:13:46.241Z",
    "modified": "2025-11-25T14:20:06.111Z"
  }
]
